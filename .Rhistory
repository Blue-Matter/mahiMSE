sel_setup = readRDS("data/sel_setup.rds")
# --- 1B --- Make a default RCM input list: OM, Data, selectivity set up -------
RCM_input_list = list(OM=OM, RCMdata=RCMdata, sel_setup=sel_setup)
# --- 1C --- Define reference set grid of operating models ---------------------
cond_grid = expand.grid(list(M=c(0.25,0.5),
Steep = c(0.7, 0.95)))
saveRDS(cond_grid, paste0(getwd(), "/fits/cond_grid.rds"))
# --- 1D --- Specify inputs to the various operating models --------------------
inputs = lapply(1:nrow(cond_grid), make_ref_input,
ref_grid = cond_grid,
RCM_input_list = RCM_input_list)
# --- 1E --- Fit the operating models in parallel ------------------------------
# 30 mins per 48 sims (270 Mb)
system.time({  fits = lapply(inputs, dofit, nsim = 48)  })
saveRDS(fits,paste0(getwd(),"/fits/fits_Aug_2025.rds"))
library(miceadds)
library(openMSE)
library(abind)
setwd("C:/Github/DolphinMSE")
source.all("code/Source")
# --- Conditioned models--------------------------------------------------------
fits = readRDS('fits/fits_Aug_2025.rds')
MOM_list = lapply(fits, RCM2MOM)
cond_grid = readRDS('fits/cond_grid.rds')
# --- Reference Grid of OMs ----------------------------------------------------
ref_grid = expand.grid(list(M = unique(cond_grid[,1]),
Steep = unique(cond_grid[,2]),
Rec = c(1, 0.75),
Visc = c(50, 75)))
saveRDS(ref_grid,'OMs/ref_grid.rds')
# --- Movement matrices --------------------------------------------------------
movs = list(mov_50 = readRDS('OMs/mov_matrices/mov_50.rds'),
mov_75 = readRDS('OMs/mov_matrices/mov_75.rds'))
xs = (1:nrow(ref_grid))[ref_grid$Rec == 1]
system.time({
RefOMs_cond = lapply(xs,vec_SMOM, cond_grid=cond_grid, ref_grid=ref_grid, MOM_list=MOM_list,
movs=movs, annual.landings=annual.landings, Fcat=Fcat, Spat_Frac=Spat_Frac)
})
dim(Fcat)
library(miceadds)
library(openMSE)
library(abind)
setwd("C:/Github/DolphinMSE")
source.all("code/Source")
# --- Conditioned models--------------------------------------------------------
fits = readRDS('fits/fits_Aug_2025.rds')
MOM_list = lapply(fits, RCM2MOM)
cond_grid = readRDS('fits/cond_grid.rds')
# --- Reference Grid of OMs ----------------------------------------------------
ref_grid = expand.grid(list(M = unique(cond_grid[,1]),
Steep = unique(cond_grid[,2]),
Rec = c(1, 0.75),
Visc = c(50, 75)))
saveRDS(ref_grid,'OMs/ref_grid.rds')
# --- Movement matrices --------------------------------------------------------
movs = list(mov_50 = readRDS('OMs/mov_matrices/mov_50.rds'),
mov_75 = readRDS('OMs/mov_matrices/mov_75.rds'))
# --- Catch datasets -----------------------------------------------------------
annual.landings = readRDS("data/annual.landings.rds") # total annual landings by large area - fleet (for checking purposes)
Fcatch = readRDS("data/Catches_s_y_F.rds")            # catch by season, yr, fleet
Spat_Frac = readRDS("data/Spat_Cat_Frac.rds")         # fraction of exploitation by fleet and region
dist = readRDS('data/VASTdist.rds')                   # a matrix of historical distributions (n time step x narea)
index = read.csv('data/VASTindex.csv')$ALL
Fcat = make_Catch_2(Fcatch, Spat_Frac, dist, index, annual.landings) # yr, f, r  make_catch_2 does spatial (within large area) distribution of catches according to the VAST index and a constant F
Fcat
xs = (1:nrow(ref_grid))[ref_grid$Rec == 1]
#sfInit(parallel=T, cpus=nrow(xs)); sfLibrary(openMSE)
#sfExport(list=c("cond_grid","ref_grid","MOM_list","movs","annual.landings","Fcat","Spat_Frac","plot_spatial_B_age","plot_sels","catch_2_F","fleets_as_areas","getSB","getF","getC","hist_comp","solveF","solveF_int","getFinds","make_SMOM","addmov", "getsels","meansel","all_recent_sel","get_recent_sel"))
# !!! Takes many hours !!!
system.time({
RefOMs_cond = lapply(xs,vec_SMOM, cond_grid=cond_grid, ref_grid=ref_grid, MOM_list=MOM_list,
movs=movs, annual.landings=annual.landings, Fcat=Fcat, Spat_Frac=Spat_Frac)
})
saveRDS(RefOMs_cond,"C:/Users/tcar_/Dropbox/temp/Dolphin/RefOMs_cond_Aug_2025.rds")
RefOMs_cond = readRDS("C:/Users/tcar_/Dropbox/temp/Dolphin/RefOMs_cond_Aug_2025.rds")
OMnames = sapply(RefOMs_cond,function(x)x@Name)
fit_match = rep(1:4,4)         # get the right spatially aggregated RCM fitted object for the ref grid
OM_match = c(1:4,1:4,5:8,5:8)  # get the right spatially conditioned operating model for the ref grid
outdir = "C:/Github/DolphinMSE/OMs/Reference_set"
for(rr in 1:nrow(ref_grid)){
RecLev = ref_grid[rr,3]
refind = OM_match[rr]
OM = make_rec(RefOMs_cond[[refind]],RecLev) # projected (subject to RecLev) and initial spool-up recruitments
OMagg = RCM2MOM(fits[[fit_match[rr]]])
OM = add_Finds(OM, OMagg)     # add indices of the various fleets
OM@Name = paste0("RefOM #",rr,": ",paste(ref_grid[rr,],collapse="-"))
OM = doLabs(OM)               # add fleet and stock names
OMlab = paste("OM",rr,sep="_")
assign(OMlab,OM)
do.call('save',args = list(OMlab,file=paste0(outdir,"/",OMlab,".RData")))
}
# OM 1
OM = readRDS("OMs/OM_template.rds")
OM@proyears = 20
nsim = 4
RCMdata = readRDS("data/RCMdata.rds")
sel_setup = readRDS("data/sel_setup.rds")
RCM_input_list = list(OM=OM, RCMdata=RCMdata, sel_setup=sel_setup)
cond_grid = expand.grid(list(M=c(0.25,0.5),Steep = c(0.7, 0.95)))
inputs = lapply(1:nrow(cond_grid), make_ref_input,ref_grid = cond_grid, RCM_input_list = RCM_input_list)
system.time({  fits = list(dofit(inputs[[1]],nsim = nsim))  })
saveRDS(fits,paste0(getwd(),"/fits/fits_micro.rds"))
MOM_list = lapply(fits, RCM2MOM)
RefOMs_cond_mini = lapply(1,vec_SMOM, cond_grid=cond_grid, ref_grid=ref_grid, MOM_list=MOM_list,
movs=movs, annual.landings=annual.landings, Fcat=Fcat, Spat_Frac=Spat_Frac)
RecLev = ref_grid[1,3]
fit_match = rep(1:4,4)         # get the right spatially aggregated RCM fitted object for the ref grid
OM_match = c(1:4,1:4,5:8,5:8)  # get the right spatially conditioned operating model for the ref grid
refind = OM_match[1]
OM = make_rec(RefOMs_cond_mini[[1]],RecLev) # projected (subject to RecLev) and initial spool-up recruitments
OMagg = RCM2MOM(fits[[1]])
OM = add_Finds(OM, OMagg)     # add indices of the various fleets
OM@Name = paste0("microOM #",1,": ",paste(ref_grid[1,],collapse="-"))
OM = doLabs(OM)
OMlab = paste("microOM",1,sep="_")
assign(OMlab,OM)
outdir = "C:/Github/DolphinMSE/OMs/Reference_set"
do.call('save',args = list(OMlab,file=paste0(outdir,"/",OMlab,".RData")))
library(miceadds)
library(openMSE)
library(mahiMSE)
Hist_micro_1 = SimulateMOM(microOM_1)      # historical fishery reconstruction
# Total TAC run
TAC2022 = sum(EffDist$C_qfr)
CurC100 = CurC50 = mahiMP ; formals(CurC100)$TAC = TAC2022; formals(CurC50)$TAC = TAC2022/2
class(CurC100) = class(CurC50) = "MMP"
microMSE = ProjectMOM(Hist_micro_1, c("CurC100","CurC50"))
mahiplot(microMSE)
mahiplot_area(microMSE,MPnams = paste0("C",c(100,50),"_lNENC"))
# x = Hist_micro_1[[1]][[1]] # area 1
Ca = round(sapply(Hist_micro_1[[1]],function(x)apply(apply(x@TSdata$Removals,1:2,sum)/1E6,2,mean)),3)
Ca2022 = apply(Ca[145:148,],2,sum)
MSE2023 = apply(apply(microMSE@Catch[,1,,1,1:4],1:2,sum),2,mean)/1e6
c(C_qfr = sum(EffDist$C_qfr)/1E6, Hist_2022 = sum(Ca2022), MSE_2023 = sum(MSE2023))
# By area
comp_area = rbind(apply(EffDist$C_qfr/1E6,3,sum),Ca2022,MSE2023); colnames(comp_area) = Areas; row.names(comp_area) = c("C_qfr","Hist_2022","MSE_2023")
round(comp_area,2)
# !! fundamental mismatch between Hist_2022 and C_qfr !!
dist = readRDS('data/VASTdist.rds') # a matrix of historical distributions (n time step x narea)
# quickly check Fcat vs C_qfr
temp_qfr = Fcat[145:148,,]
# Testing spatial catch solution:
library(miceadds); library(openMSE); library(abind)
setwd("C:/Github/DolphinMSE"); source.all("code/Source")
#fits = readRDS('fits/fits_June_2025.rds')
#MOM_list = lapply(fits, RCM2MOM)
cond_grid = readRDS('fits/cond_grid.rds')
ref_grid = expand.grid(list(M = unique(cond_grid[,1]),
Steep = unique(cond_grid[,2]),
Rec = c(1, 0.75),
Visc = c(50, 75)))
movs = list(mov_50 = readRDS('OMs/mov_matrices/mov_50.rds'),
mov_75 = readRDS('OMs/mov_matrices/mov_75.rds'))
annual.landings = readRDS("data/annual.landings.rds") # total annual landings by large area - fleet (for checking purposes)
Fcatch = readRDS("data/Catches_s_y_F.rds")            # catch by season, yr, fleet
Spat_Frac = readRDS("data/Spat_Cat_Frac.rds")         # fraction of exploitation by fleet and region
dist = readRDS('data/VASTdist.rds')                   # a matrix of historical distributions (n time step x narea)
index = read.csv('data/VASTindex.csv')$ALL
Fcat = make_Catch_2(Fcatch, Spat_Frac, dist, index, annual.landings) # yr, f, r  make_catch_2 does spatial (within large area) distribution of catches according to the VAST index and a constant F
#fits = readRDS("C:/Users/tcar_/Dropbox/temp/Dolphin/fits/fits_micro.rds")
fits = readRDS(paste0(getwd(),"/fits/fits_micro.rds"))
MOM_list = lapply(fits, RCM2MOM)
#RefOMs_cond_mini = lapply(1,vec_SMOM, cond_grid=cond_grid, ref_grid=ref_grid, MOM_list=MOM_list,
#                          movs=movs, annual.landings=annual.landings, Fcat=Fcat, Spat_Frac=Spat_Frac)
# Load VAST index for historical reconstruction of spatial distribution
dist = readRDS('data/VASTdist.rds') # a matrix of historical distributions (n time step x narea)
# quickly check Fcat vs C_qfr
temp_qfr = Fcat[145:148,,]
sum(temp_qfr) == sum(EffDist$C_qfr)
apply(temp_qfr,2,sum)==apply(EffDist$C_qfr,2,sum)
# Code/Fleet_mapping.R
# vec_SMOM
x=1
sets = ref_grid[x,]
movno = match(paste0("mov_",sets$Visc), names(movs))
OMno = (1:length(MOM_list))[sets$M == cond_grid$M & sets$Steep == cond_grid$Steep]
MOM = MOM_list[[OMno]]; mov = movs[[movno]]; plot=T; delta = 0.2;  tol = 1E3; maxitns = 10; cols = c("black","green","red","blue","orange","purple","darkgrey")
Hist00 = SimulateMOM(MOM) # spatially aggregated reconstruction
C00 = getC(Hist00) / 1000 # cbind(C00[1,],apply(fit@data@Chist,1,sum)/1000, apply(Fcat,1,sum)/1000)
dim(COO)
dim(C00)
matplot(t(C00),type="l")
dim(Fcat)
cbind(C00[1,],apply(fit@data@Chist,1,sum)/1000
cbind(C00[1,],apply(fit@data@Chist,1,sum)/1000, apply(Fcat,1,sum)/1000)
cbind(C00[1,],apply(fits[[1]]@data@Chist,1,sum)/1000, apply(Fcat,1,sum)/1000)
hsim=1; par(mfrow=c(1,3));matplot(Hist00[[1]][[1]]@TSdata$Biomass[hsim,,],type="l")
F00 = getF(Hist00)
B00 = getSB(Hist00) / 1000
nsim = MOM@nsim
SMOM = addmov(MOM, mov[1:nsim,,,,])
anams = sapply(dimnames(mov)[[3]],function(x)strsplit(x,"from_")[[1]][2])
anams
cat("1: Initial historical reconstruction \n")
Hist0 = SimulateMOM(SMOM) # spatially disaggregated reconstruction
matplot(Hist0[[1]][[1]]@TSdata$Biomass[hsim,,],type="l")
C0 = getC(Hist0)
dim(C0)
C0 = getC(Hist0)/1000
cbind(C0[1,],apply(fits[[1]]@data@Chist,1,sum)/1000, apply(Fcat,1,sum)/1000)
cat("2: Calculate the aggregate F for each area \n")
Nmat = Hist[[1]][[1]]@AtAge$Number                 # 1 Numbers
Hist=Hist0
Nmat = Hist[[1]][[1]]@AtAge$Number                 # 1 Numbers
dim(Nmat)
dims = dim(Nmat)
nsim = dims[1]; na = dims[2]; ny = dims[3]; nr = dims[4] # sim, age(quarter), year(quarter), region
nf = dim(Fcat)[2] # nf=length(Hist[[1]]);
Fi = getFinds(Hist)                                # 3 Apical F last estimated
Wt = Hist[[1]][[1]]@AtAge$Weight                   # 5 Weight at age
dim(Wt)
gridy = expand.grid(1:nsim, 1:ny, 1:nf, 1:nr)      # stuff to solve
nrun = nsim*ny*nf*nr                               # numbers of runs
x<-2000
sim = gridy[x,1]; yy = gridy[x,2]; ff = gridy[x,3]; rr = gridy[x,4]
sim
yy
ff
rr
dim(Fcat)
ff
dim(Hist[[1]][[1]]@TSdata$Biomass)
dim(sels)
sels = all_recent_sel(Hist0)
dim(sels)
sels
dim(sels)
sels_FasA = all_recent_sel(Hist)
if(plot) compHist(dist,Hist0,1:148,rep(1,2))
if(plot) plot_spatial_B_age(Hist0,anams=anams)
if(plot) plot_sels(Hist0)
sels = all_recent_sel(Hist0)
# C0 = getC(Hist0)/1000;  cbind(C0[1,],apply(fits[[1]]@data@Chist,1,sum)/1000, apply(Fcat,1,sum)/1000)
# 2 The implied spatial F by fleet summed over areas (fleets as areas)
cat("2: Calculate the aggregate F for each area \n")
Fs = catch_2_F(Hist0, Fcat, sels) # list pos 1 is sim, yr, age class, area. List pos 2 is sim, yr, area (apical F)
# 3 Remake spatial OM to have fleets as areas
SMOM2 = fleets_as_areas(SMOM, Fs) # copy
Hist = SimulateMOM(SMOM2) # spatial disaggregated reconstruction, fleets as areas
if(plot) compHist(dist,Hist,1:148,rep(1,2))
matplot(Hist[[1]][[1]]@TSdata$Biomass[hsim,,],type="l")
compHist(dist,Hist,1:148,rep(1,2))
cat("2: Calculate the aggregate F for each area \n")
Fs = catch_2_F(Hist0, Fcat, sels) # list pos 1 is sim, yr, age class, area. List pos 2 is sim, yr, area (apical F)
# 3 Remake spatial OM to have fleets as areas
SMOM2 = fleets_as_areas(SMOM, Fs) # copy
Hist = SimulateMOM(SMOM2) # spatial disaggregated reconstruction, fleets as areas
if(plot) compHist(dist,Hist,1:148,rep(1,2))
matplot(Hist[[1]][[1]]@TSdata$Biomass[hsim,,],type="l")
dim(sels)
Hist=Hist0
dim(Fcat)
dim(sels)
SMOM2 = SMOM        # copy spatial OM
nsim = SMOM@nsim
mov = SMOM@cpars[[1]][[1]]$mov
nr = dim(mov)[4]
cpars0 = SMOM@cpars[[1]][[1]]
V0 = cpars0$V
na = dim(V0)[2]
Fleet0 = SMOM@Fleets[[1]][[1]]
SMOM2@Fleets[[1]] = list()
allyears = dim(cpars0$ageMarray)[2]
MPA0 = array(0,c(allyears, nr))
nr
SMOM2@Fleets[[1]][[ff]] = Fleet0 # just remap to keep dimensions nareas (nfleets) big
cpars =  cpars0 # copy
dim(Fs)
Fs = catch_2_F(Hist0, Fcat, sels) # list pos 1 is sim, yr, age class, area. List pos 2 is sim, yr, area (apical F)
dim(Fs)
dim(Fs)[[``]]
dim(Fs)[[1]]
dim(Fs[[2]])
dim(Fs[[1]])
SMOM2 = SMOM        # copy spatial OM
nsim = SMOM@nsim
mov = SMOM@cpars[[1]][[1]]$mov
nr = dim(mov)[4]
cpars0 = SMOM@cpars[[1]][[1]]
V0 = cpars0$V
na = dim(V0)[2]
Fleet0 = SMOM@Fleets[[1]][[1]]
SMOM2@Fleets[[1]] = list()
allyears = dim(cpars0$ageMarray)[2]
MPA0 = array(0,c(allyears, nr))
dim(Fcat)
Nmat = Hist[[1]][[1]]@AtAge$Number                 # 1 Numbers
dims = dim(Nmat)
nsim = dims[1]; na = dims[2]; ny = dims[3]; nr = dims[4] # sim, age(quarter), year(quarter), region
nf = dim(Fcat)[2] # nf=length(Hist[[1]]);
Fi = getFinds(Hist)                                # 3 Apical F last estimated
Wt = Hist[[1]][[1]]@AtAge$Weight                   # 5 Weight at age
gridy = expand.grid(1:nsim, 1:ny, 1:nr)      # stuff to solve
nrun = nsim*ny*nr                               # numbers of runs
Mage = Hist[[1]][[1]]@AtAge$N.Mortality
dim(Mage)
Nmat = Hist[[1]][[1]]@AtAge$Number                 # 1 Numbers
Mage = Hist[[1]][[1]]@AtAge$N.Mortality
dims = dim(Nmat)
nsim = dims[1]; na = dims[2]; ny = dims[3]; nr = dims[4] # sim, age(quarter), year(quarter), region
nf = dim(Fcat)[2] # nf=length(Hist[[1]]);
Fi = getFinds(Hist)                                # 3 Apical F last estimated
Wt = Hist[[1]][[1]]@AtAge$Weight                   # 5 Weight at age
gridy = expand.grid(1:nsim, 1:ny, 1:nr)      # stuff to solve
nrun = nsim*ny*nr                               # numbers of runs
x
sim = gridy[x,1]; yy = gridy[x,2]; rr = gridy[x,4]
C_i = Fcat[yy,,rr]
C_i
Fcat[yy,,rr]
yy
rr
sim = gridy[x,1]; yy = gridy[x,2]; rr = gridy[x,3]
C_i = Fcat[yy,,rr]
C_i
S_i = sels[sim,,ff]
S_i
S_i = sels[sim,,]
N_i = Nmat[sim,,yy,rr]
dim(Fi)
Nmat = Hist0[[1]][[1]]@AtAge$Number                 # 1 Numbers
dims = dim(Nmat)
nsim = dims[1]; na = dims[2]; ny = dims[3]; nr = dims[4] # sim, age(quarter), year(quarter), region
nf = dim(Fcat)[2] # nf=length(Hist[[1]]);
Fi = getFinds(Hist0)                                # 3 Apical F last estimated
Wt = Hist0[[1]][[1]]@AtAge$Weight                   # 5 Weight at age
gridy = expand.grid(1:nsim, 1:ny, 1:nf, 1:nr)      # stuff to solve
nrun = nsim*ny*nf*nr                               # numbers of runs
setup()
sfExport('solveF_int')
Fs = sfSapply(1:nrun, solveF, gridy=gridy, Fcat=Fcat, Nmat=Nmat, sels=sels, Fi=Fi, Wt=Wt)
Fmat = array(Fs,c(nsim,ny,nf,nr))
Famat = array(NA,c(nsim,ny,nf,na,nr))
Find = as.matrix(expand.grid(1:nsim,1:ny,1:nf,1:na,1:nr))
Famat[Find] = Fmat[Find[,c(1,2,3,5)]] * sels[Find[,c(1,4,3)]]
Fout = apply(Famat, c(1,2,4,5), sum)
Findsum = apply(Fmat,c(1,2,4),sum)
dim(Famat)
ss = gridy_r[x,1]; yy = gridy_r[x,2]; rr = gridy_r[x,3]
gridy_r = expand.grid(1:nsim, 1:ny, 1:nr)      # stuff to solve
nrun_r = nsim*ny*nr
Mage = Hist0[[1]][[1]]@AtAge$N.Mortality
ss = gridy_r[x,1]; yy = gridy_r[x,2]; rr = gridy_r[x,3]
ss
yy
rr
dim(Famat)
Famat[ss,yy,,,rr]
dim(Nmat)
Nmat[ss,,yy,,rr]
Nmat[ss,,yy,rr]
exp(-0.2)
dim(Mage)
exp(-Mage[ss,,yy])
exp(-Mage[ss,,yy]/2)
Hist0[[1]][[1]]@AtAge$Weight
dim(Wt)
dim( Famat[ss,yy,,,rr])
Nmat[ss,,yy,rr]
exp(-Mage[ss,,yy]/2)
Wt[ss,,yy]
predCat = t(Famat[ss,yy,,,rr]) * Nmat[ss,,yy,rr] * exp(-Mage[ss,,yy]/2) * Wt[ss,,yy]
predCat
Famat[ss,yy,,,rr]
retCattot = sum(predCat)
pretCattot = sum(predCat)
pretCattot
dim(Fcat)
obsCat = sum(Fcat[yy,,rr])
pretCattot
obsCat
library(ABTMSE)
Shiny('ABTMSE')
ss = gridy_r[x,1]; yy = gridy_r[x,2]; rr = gridy_r[x,3]
FF= t(Famat[ss,yy,,,rr])
NN=Nmat[ss,,yy,rr]
MM = -Mage[ss,,yy]/2
WW = Wt[ss,,yy]
Cobs = sum(Fcat[yy,,rr])
solve_totC_int = function(par,FF,NN,MM,WW,Cobs){
predcat = FF*NN*exp(-MM/2)*WW
((exp(par) * sum(predcat)) - Cobs)^2
}
opt =  optimize(solve_totC_int,c(-3,3), FF=FF,NN=NN,MM=MM,WW=WW,Cobs=Cobs)
opt$minimum
exp(opt$minimum)
solve_totC_int = function(par,FF,NN,MM,WW,Cobs){
predcat = exp(par)*FF*NN*exp(-MM/2)*WW
(sum(predcat) - Cobs)^2
}
ss = gridy_r[x,1]; yy = gridy_r[x,2]; rr = gridy_r[x,3]
FF= t(Famat[ss,yy,,,rr])
NN=Nmat[ss,,yy,rr]
MM = -Mage[ss,,yy]/2
WW = Wt[ss,,yy]
Cobs = sum(Fcat[yy,,rr])
opt =  optimize(solve_totC_int,c(-3,3), FF=FF,NN=NN,MM=MM,WW=WW,Cobs=Cobs)
sum(exp(opt$minimum)*FF*NN*exp(-MM/2)*WW)/Cobs
solve_totC_int = function(par,FF,NN,MM,WW,Cobs){
predcat = exp(par)*FF*NN*exp(-MM/2)*WW
(sum(predcat) - Cobs)^2
}
solve_totC = function(x, gridy_r, Nmat, Fcat, Famat, Mage, Wt){
ss = gridy_r[x,1]; yy = gridy_r[x,2]; rr = gridy_r[x,3]
FF= t(Famat[ss,yy,,,rr])
NN=Nmat[ss,,yy,rr]
MM = -Mage[ss,,yy]/2
WW = Wt[ss,,yy]
Cobs = sum(Fcat[yy,,rr])
opt =  optimize(solve_totC_int,c(-3,3), FF=FF,NN=NN,MM=MM,WW=WW,Cobs=Cobs)
#sum(exp(opt$minimum)*FF*NN*exp(-MM/2)*WW)/Cobs
exp(opt$minimum)
}
gridy_r = expand.grid(1:nsim, 1:ny, 1:nr)      # stuff to solve
nrun_r = nsim*ny*nr
Mage = Hist0[[1]][[1]]@AtAge$N.Mortality
Fmod = sapply(1:nrun_r, solve_totC, gridy_r = gridy_r, Nmat = Nmat, Fcat = Fcat, Famat=Famat, Mage=Mage, Wt = Wt)
Fmodarr = array(Fmod,c(nsim,ny,nr))
Fmodarr
gridy = as.matrix(expand.grid(1:nsim, 1:ny, 1:nf, 1:nr))      # stuff to solve
nrun = nsim*ny*nf*nr                               # numbers of runs
setup()
sfExport('solveF_int')
Fs = sfSapply(1:nrun, solveF, gridy=gridy, Fcat=Fcat, Nmat=Nmat, sels=sels, Fi=Fi, Wt=Wt)
Fmat = array(Fs,c(nsim,ny,nf,nr))
Famat = array(NA,c(nsim,ny,nf,na,nr))
Find = as.matrix(expand.grid(1:nsim,1:ny,1:nf,1:na,1:nr))
Famat[Find] = Fmat[Find[,c(1,2,3,5)]] * sels[Find[,c(1,4,3)]]
Fout = apply(Famat, c(1,2,4,5), sum)
Findsum = apply(Fmat,c(1,2,4),sum)
gridy_r = expand.grid(1:nsim, 1:ny, 1:nr)      # stuff to solve
nrun_r = nsim*ny*nr
Mage = Hist0[[1]][[1]]@AtAge$N.Mortality
Fmod = sapply(1:nrun_r, solve_totC, gridy_r = gridy_r, Nmat = Nmat, Fcat = Fcat, Famat=Famat, Mage=Mage, Wt = Wt)
Fmodarr = array(Fmod,c(nsim,ny,nr))
Famat2 = array(NA,dim(Famat))
Fmat2 = array(NA, dim(Fmat))
Fmat2[gridy] = Fmat[gridy] * Fmodarr[gridy[,c(1,2,4)]]
Famat2[Find] = Famat[Find] * Fmodarr[Find[,c(1,2,5)]]
simno=1
ageclass = 17
yrs = ny-3:0
print(Famat2[simno,yrs[1],,ageclass,])
print(Famat2[simno,yrs[2],,ageclass,])
print(Famat2[simno,yrs[3],,ageclass,])
print(Famat2[simno,yrs[4],,ageclass,])
nrun_r
source("C:/GitHub/DolphinMSE/code/Source/Fleet_mapping.R")
cat("2: Calculate the aggregate F for each area \n")
Fs = catch_2_F(Hist0, Fcat, sels) # list pos 1 is sim, yr, age class, area. List pos 2 is sim, yr, area (apical F)
source("C:/GitHub/DolphinMSE/code/Source/Fleet_mapping.R")
cat("2: Calculate the aggregate F for each area \n")
Fs = catch_2_F(Hist0, Fcat, sels) # list pos 1 is sim, yr, age class, area. List pos 2 is sim, yr, area (apical F)
SMOM2 = fleets_as_areas(SMOM, Fs) # copy
Hist = SimulateMOM(SMOM2) # spatial disaggregated reconstruction, fleets as areas
compHist(dist,Hist,1:148,rep(1,2))
dim(Fs[[1]])
dim(Fs[[2]])
x=Hist[[1]][[1]]
dim(x@TSdata$Removals)
Cat = sapply(Hist[[1]],function(x)apply(x@TSdata$Removals,1:2,sum))
dim(Cat)
Cat =lapply(Hist[[1]],function(x)apply(x@TSdata$Removals,1:2,sum))
Cat[[1]]
dim(Fcat)
ndist = dist[yind,] / mean(dist[yind,])
yind = 1:148
simno=1:3
plotype="Bio"
ndist = dist[yind,] / mean(dist[yind,])
Bio = Hist[[1]][[1]]@TSdata$Biomass[,yind,]
nr = length(Hist[[1]])
Cat =lapply(Hist[[1]],function(x)apply(x@TSdata$Removals,1:2,sum))
nsim = dim(Bio)[1]
for(i in 1:nsim)Bio[i,,]=Bio[i,,]/mean(Bio[i,,])
par(mfrow=c(3,3))
for(rr in 1:length(Areas)){
matplot(cbind(ndist[,rr],t(Bio[simno,,rr])),type="l",col=c("black","red","green","blue"),lty=1,lwd=c(2,1,1,1))
legend('topleft',legend=Areas[rr])
}
Fsum = apply(Fcat,c(1,3),sum)
Fsum
for(rr in 1:length(Areas)){
matplot(cbind(Fsum[,rr],t(Cat[[rr]][simno,])),type="l",col=c("black","red","green","blue"),lty=1,lwd=c(2,1,1,1))
legend('topleft',legend=Areas[rr])
}
for(rr in 1:length(Areas)){
matplot(cbind(Fsum[,rr],t(Cat[[rr]][simno,])),type="l",col=c("black","red","green","blue"),lty=1,lwd=c(2,1,1,1))
legend('topleft',legend=Areas[rr])
}
par(mfrow=c(3,3))
Fsum = apply(Fcat,c(1,3),sum)
for(rr in 1:length(Areas)){
matplot(cbind(Fsum[,rr],t(Cat[[rr]][simno,])),type="l",col=c("black","red","green","blue"),lty=1,lwd=c(2,1,1,1))
legend('topleft',legend=Areas[rr])
}
sels
dim(sels)
Hist00 = SimulateMOM(MOM) # spatially aggregated reconstruction
C00 = getC(Hist00) / 1000 # cbind(C00[1,],apply(fits[[1]]@data@Chist,1,sum)/1000, apply(Fcat,1,sum)/1000)
hsim=1; par(mfrow=c(1,3));matplot(Hist00[[1]][[1]]@TSdata$Biomass[hsim,,],type="l")
## sum(apply(C00[,145:148],2,mean))/1000 #(kt)
F00 = getF(Hist00)
B00 = getSB(Hist00) / 1000
nsim = MOM@nsim
SMOM = addmov(MOM, mov[1:nsim,,,,])
anams = sapply(dimnames(mov)[[3]],function(x)strsplit(x,"from_")[[1]][2])
# 1 Initial historical reconstruction
cat("1: Initial historical reconstruction \n")
Hist0 = SimulateMOM(SMOM) # spatially disaggregated reconstruction
matplot(Hist0[[1]][[1]]@TSdata$Biomass[hsim,,],type="l")
if(plot) compHist(dist,Hist0,1:148,rep(1,2))
